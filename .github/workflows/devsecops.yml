name: DevSecOps Pipeline - InvisiThreat

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]


env:
  DD_URL: http://localhost:8080
  PERIOD_MODE: "quarterly"
  FAIL_ON_NEW_CRITICAL: "true"
  FAIL_ON_NEW_HIGH: "false"

jobs:
  security:
    name: ğŸ” SAST + SCA + DAST + DefectDojo
    runs-on: self-hosted
    timeout-minutes: 120

    steps:

    
    - name:  RÃ©cupÃ©rer le code
      uses: actions/checkout@v4
      with:
        submodules: recursive
        fetch-depth: 0

    
    - name:  Installer jq
      run: |
        if command -v jq &> /dev/null; then
          echo " jq dÃ©jÃ  installÃ©: $(jq --version)"
          exit 0
        fi
        echo " Nettoyage des processus apt bloquÃ©s..."
        sudo killall apt apt-get dpkg 2>/dev/null || true
        sudo rm -f /var/lib/dpkg/lock-frontend /var/lib/dpkg/lock \
                   /var/cache/apt/archives/lock /var/lib/apt/lists/lock
        sudo dpkg --configure -a
        if sudo apt update -qq && sudo apt install -y -qq jq; then
          echo " jq installÃ© via apt: $(jq --version)"
        else
          echo " Ã‰chec apt, installation via binaire..."
          wget -q -O jq https://github.com/jqlang/jq/releases/download/jq-1.7.1/jq-linux64
          chmod +x jq && sudo mv jq /usr/local/bin/
          echo " jq installÃ© via binaire: $(jq --version)"
        fi

    - name:  Installer les dÃ©pendances Node
      working-directory: ./juice-shop
      run: |
        if [ -f "package-lock.json" ]; then
          echo " Installation avec npm ci..."
          npm ci
        else
          echo " Installation avec npm install..."
          npm install
        fi

   
    - name:  SAST avec Semgrep
      working-directory: ./juice-shop
      continue-on-error: true
      run: |
        [ -f ".semgrepignore" ] && mv .semgrepignore .semgrepignore.bak
        timeout 1500 docker run --rm -v "$(pwd):/src" returntocorp/semgrep semgrep \
          --config=r/all --json --output=/src/semgrep-results.json \
          --metrics=off --jobs=4 --timeout=60 --max-memory=4096 /src || true
        [ -f ".semgrepignore.bak" ] && mv .semgrepignore.bak .semgrepignore
        [ ! -s "semgrep-results.json" ] && echo '{"results":[]}' > semgrep-results.json

        echo ""; echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo "   SEMGREP RAPPORT"
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        jq -r '"  ğŸ” Total: " + (.results | length | tostring) +
              "\n  ğŸ”´ High: " + ([.results[] | select(.extra.severity=="ERROR")] | length | tostring) +
              "\n  ğŸŸ  Med: " + ([.results[] | select(.extra.severity=="WARNING")] | length | tostring) +
              "\n  ğŸŸ¡ Low: " + ([.results[] | select(.extra.severity=="INFO")] | length | tostring)' semgrep-results.json
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo " PrÃªt pour DefectDojo"

   
    - name:  Snyk SCA
      continue-on-error: true
      working-directory: ./juice-shop
      env:
        SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
      run: |
        echo " Scan Snyk en cours..."
        npx snyk test --severity-threshold=low \
          --json-file-output=snyk-results.json || true

        if [ ! -f "snyk-results.json" ] || [ ! -s "snyk-results.json" ]; then
          echo '{"vulnerabilities":[]}' > snyk-results.json
          echo " Fichier snyk-results.json crÃ©Ã© (vide)"
        else
          COUNT=$(jq '.vulnerabilities | length' snyk-results.json 2>/dev/null || echo "0")
          echo " Snyk terminÃ© : $COUNT vulnÃ©rabilitÃ©s trouvÃ©es"
        fi

    - name:  Snyk Monitor
      continue-on-error: true
      working-directory: ./juice-shop
      env:
        SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
      run: |
        echo " Envoi des donnÃ©es Ã  Snyk Monitor..."
        npx snyk monitor || true

   
    - name:  DÃ©marrer l'API en arriÃ¨re-plan
      working-directory: ./juice-shop
      run: |
        echo " DÃ©marrage de l'API sur http://localhost:3000"
        npm start &
        echo $! > api.pid
        sleep 15

        MAX_RETRIES=20
        for i in $(seq 1 $MAX_RETRIES); do
          if curl -s -f http://localhost:3000/ > /dev/null 2>&1; then
            echo " API dÃ©marrÃ©e avec succÃ¨s"
            exit 0
          fi
          echo " Tentative $i/$MAX_RETRIES..."
          sleep 3
        done
        echo " API n'a pas dÃ©marrÃ©"
        exit 1

    - name:  DAST - Scan OpenAPI
      working-directory: ./juice-shop
      continue-on-error: true
      run: |
        echo " Scan OpenAPI avec ZAP..."

        RULES_FILE=""
        if [ -f ".zap/rules.tsv" ]; then
          echo " Utilisation des rÃ¨gles: .zap/rules.tsv"
          RULES_FILE="-c .zap/rules.tsv"
        fi

        API_FILE=""
        for file in swagger.yml swagger.yaml openapi.json swagger.json; do
          if [ -f "$file" ]; then
            API_FILE="$file"
            echo " Fichier OpenAPI trouvÃ©: $file"
            break
          fi
        done

        if [ -n "$API_FILE" ]; then
          docker run --rm --network host -v "$(pwd):/zap/wrk:rw" \
            ghcr.io/zaproxy/zaproxy:stable \
            zap-api-scan.py \
            -t http://localhost:3000 \
            -f openapi \
            -d "/zap/wrk/$API_FILE" \
            -x /zap/wrk/zap-openapi.xml \
            -J /zap/wrk/zap-openapi.json \
            $RULES_FILE \
            -T 30 \
            -I || true
        else
          echo " Aucun fichier OpenAPI trouvÃ©, scan sans spÃ©cification"
          docker run --rm --network host -v "$(pwd):/zap/wrk:rw" \
            ghcr.io/zaproxy/zaproxy:stable \
            zap-api-scan.py \
            -t http://localhost:3000 \
            -f openapi \
            -x /zap/wrk/zap-openapi.xml \
            -J /zap/wrk/zap-openapi.json \
            $RULES_FILE \
            -T 30 \
            -I || true
        fi

    - name:  VÃ©rifier rapport OpenAPI
      working-directory: ./juice-shop
      run: |
        if [ -f zap-openapi.json ]; then
          echo " zap-openapi.json trouvÃ©"
          echo "Taille: $(stat -c%s zap-openapi.json 2>/dev/null || stat -f%z zap-openapi.json 2>/dev/null) octets"
        elif [ -f zap_out.json ]; then
          cp zap_out.json zap-openapi.json
          echo " RenommÃ© zap_out.json en zap-openapi.json"
        elif [ -f report_json.json ]; then
          cp report_json.json zap-openapi.json
          echo " RenommÃ© report_json.json en zap-openapi.json"
        else
          echo " Aucun rapport OpenAPI trouvÃ©"
          echo "[]" > zap-openapi.json
        fi

    - name:  DAST - Spider Scan
      continue-on-error: true
      timeout-minutes: 30
      working-directory: ./juice-shop
      run: |
        echo " Spider Scan avec rÃ¨gles personnalisÃ©es..."

        RULES_FILE=""
        if [ -f ".zap/rules.tsv" ]; then
          echo " Utilisation du fichier de rÃ¨gles: .zap/rules.tsv"
          grep "IGNORE" .zap/rules.tsv | head -5
          RULES_FILE="-c .zap/rules.tsv"
        fi

        docker run --rm --network host -v "$(pwd):/zap/wrk:rw" \
          ghcr.io/zaproxy/zaproxy:stable \
          zap-baseline.py \
          -t http://localhost:3000 \
          $RULES_FILE \
          -x /zap/wrk/zap-spider.xml \
          -J /zap/wrk/zap-spider.json \
          -T 15 \
          -m 2 || echo " Scan terminÃ©"

    - name:  VÃ©rifier rapport Spider
      working-directory: ./juice-shop
      run: |
        if [ -f zap-spider.json ]; then
          echo " zap-spider.json trouvÃ©"
        elif [ -f zap-out.json ]; then
          cp zap-out.json zap-spider.json
          echo " RenommÃ© zap-out.json en zap-spider.json"
        else
          echo " Aucun rapport Spider trouvÃ©"
          echo "[]" > zap-spider.json
        fi

    - name:  DAST - Active Scan
      continue-on-error: true
      timeout-minutes: 40
      working-directory: ./juice-shop
      run: |
        echo " Scan actif avec ZAP (peut prendre 30-40 minutes)..."

        RULES_FILE=""
        if [ -f ".zap/rules.tsv" ]; then
          echo " Utilisation des rÃ¨gles pour l'Active Scan"
          RULES_FILE="-c .zap/rules.tsv"
        fi

        docker run --rm --network host -v "$(pwd):/zap/wrk:rw" \
          ghcr.io/zaproxy/zaproxy:stable \
          zap-full-scan.py \
          -t http://localhost:3000 \
          -x /zap/wrk/zap-active.xml \
          -J /zap/wrk/zap-active.json \
          $RULES_FILE \
          -T 30 || true

    - name:  VÃ©rifier rapport Active Scan
      working-directory: ./juice-shop
      run: |
        if [ -f zap-active.json ]; then
          echo " zap-active.json trouvÃ©"
        elif [ -f zap-out.json ]; then
          cp zap-out.json zap-active.json
          echo " RenommÃ© zap-out.json en zap-active.json"
        else
          echo " Aucun rapport Active Scan trouvÃ©"
          echo "[]" > zap-active.json
        fi

    - name:  Consolider les rapports DAST
      working-directory: ./juice-shop
      run: |
        echo " Consolidation des rapports DAST..."
        echo "[]" > zap-consolidated.json
        if ls zap-*.json 1> /dev/null 2>&1; then
          jq -s 'add' zap-*.json > zap-consolidated.json 2>/dev/null || echo "[]" > zap-consolidated.json
        fi

        if [ -s zap-consolidated.json ]; then
          TOTAL=$(jq 'length' zap-consolidated.json 2>/dev/null || echo "0")
          CRITICAL=$(jq '[.[] | select(.riskcode=="3")] | length' zap-consolidated.json 2>/dev/null || echo "0")
          HIGH=$(jq '[.[] | select(.riskcode=="2")] | length' zap-consolidated.json 2>/dev/null || echo "0")
          MEDIUM=$(jq '[.[] | select(.riskcode=="1")] | length' zap-consolidated.json 2>/dev/null || echo "0")
          LOW=$(jq '[.[] | select(.riskcode=="0")] | length' zap-consolidated.json 2>/dev/null || echo "0")
          echo " RÃ‰SULTATS DAST:"
          echo "   Total       : $TOTAL vulnÃ©rabilitÃ©s"
          echo "   ğŸ”´ Critiques : $CRITICAL"
          echo "   ğŸŸ  Hautes    : $HIGH"
          echo "   ğŸŸ¡ Moyennes  : $MEDIUM"
          echo "   ğŸŸ¢ Basses    : $LOW"
        else
          echo "â„¹ Aucune vulnÃ©rabilitÃ© consolidÃ©e"
        fi


    - name:  ArrÃªter l'API
      if: always()
      working-directory: ./juice-shop
      run: |
        echo " ArrÃªt de l'API..."
        if [ -f api.pid ]; then
          PID=$(cat api.pid)
          kill $PID 2>/dev/null || true
          rm -f api.pid
          echo " API arrÃªtÃ©e (PID: $PID)"
        fi
        pkill -f "node.*juice-shop" || true
        echo " Nettoyage des processus terminÃ©"

    
    - name: ğŸ“¤ Upload tous les rapports de sÃ©curitÃ©
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: security-reports-${{ github.sha }}
        path: |
          juice-shop/semgrep-results.json
          juice-shop/snyk-results.json
          juice-shop/zap-*.json
          juice-shop/zap-*.xml
          juice-shop/.zap/rules.tsv
        retention-days: 30
        if-no-files-found: warn

 
    - name: ğŸ”µ DefectDojo â€” RÃ©soudre l'Engagement
      if: always()
      id: dd_engagement
      env:
        DD_API_KEY: ${{ secrets.DEFECTDOJO_API_KEY }}
        PRODUCT_ID: ${{ secrets.PRODUCT_ID }}
      run: |
        set -e

        BRANCH="${{ github.ref_name }}"

        # â”€â”€ Calcul de la pÃ©riode â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        if [ "$PERIOD_MODE" = "quarterly" ]; then
          MONTH=$(date +%-m)
          YEAR=$(date +%Y)
          if   [ $MONTH -le 3 ]; then
            PERIOD="Q1"; PERIOD_START="${YEAR}-01-01"; PERIOD_END="${YEAR}-03-31"
          elif [ $MONTH -le 6 ]; then
            PERIOD="Q2"; PERIOD_START="${YEAR}-04-01"; PERIOD_END="${YEAR}-06-30"
          elif [ $MONTH -le 9 ]; then
            PERIOD="Q3"; PERIOD_START="${YEAR}-07-01"; PERIOD_END="${YEAR}-09-30"
          else
            PERIOD="Q4"; PERIOD_START="${YEAR}-10-01"; PERIOD_END="${YEAR}-12-31"
          fi
          ENGAGEMENT_NAME="${BRANCH} - ${YEAR}-${PERIOD}"

        elif [ "$PERIOD_MODE" = "monthly" ]; then
          PERIOD=$(date +%Y-%m)
          PERIOD_START=$(date +%Y-%m-01)
          PERIOD_END=$(date -d "$(date +%Y-%m-01) +1 month -1 day" +%Y-%m-%d)
          ENGAGEMENT_NAME="${BRANCH} - ${PERIOD}"

        elif [ "$PERIOD_MODE" = "weekly" ]; then
          PERIOD="W$(date +%V)-$(date +%Y)"
          PERIOD_START=$(date -d "last Monday" +%Y-%m-%d 2>/dev/null || date +%Y-%m-%d)
          PERIOD_END=$(date -d "next Sunday" +%Y-%m-%d 2>/dev/null || date +%Y-%m-%d)
          ENGAGEMENT_NAME="${BRANCH} - ${PERIOD}"
        fi

        echo " Mode       : $PERIOD_MODE"
        echo "  Engagement : $ENGAGEMENT_NAME"
        echo " PÃ©riode    : $PERIOD_START â†’ $PERIOD_END"

        # â”€â”€ Encodage URL 100% bash (sans python3) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        # Remplace les espaces par %20 et les caractÃ¨res spÃ©ciaux
        # Note : on utilise le tiret simple "-" dans le nom
        # pour Ã©viter tout problÃ¨me d'encodage avec "â€”"
        urlencode() {
          local string="$1"
          local encoded=""
          local i
          for (( i=0; i<${#string}; i++ )); do
            local c="${string:$i:1}"
            case "$c" in
              [a-zA-Z0-9._~-]) encoded+="$c" ;;
              ' ') encoded+="%20" ;;
              *) encoded+=$(printf '%%%02X' "'$c") ;;
            esac
          done
          echo "$encoded"
        }

        ENCODED_NAME=$(urlencode "$ENGAGEMENT_NAME")
        ENCODED_STATUS=$(urlencode "In Progress")

        echo " Recherche d'un engagement existant..."
        SEARCH=$(curl -s \
          "${DD_URL}/api/v2/engagements/?product=${PRODUCT_ID}&name=${ENCODED_NAME}&status=${ENCODED_STATUS}" \
          -H "Authorization: Token $DD_API_KEY")

        # Lecture du count via jq (plus de python3)
        COUNT=$(echo "$SEARCH" | jq -r '.count // 0')
        echo " Engagements trouvÃ©s : $COUNT"

        if [ "$COUNT" -gt "0" ]; then
          #  RÃ©utilisation â€” on prend l'ID le plus Ã©levÃ©
          ENGAGEMENT_ID=$(echo "$SEARCH" | jq -r '.results | sort_by(.id) | reverse | .[0].id')
          echo "  Engagement existant rÃ©utilisÃ© â€” ID: $ENGAGEMENT_ID"

          # PATCH minimal : uniquement target_end
          curl -s -X PATCH "${DD_URL}/api/v2/engagements/${ENGAGEMENT_ID}/" \
            -H "Authorization: Token $DD_API_KEY" \
            -H "Content-Type: application/json" \
            -d "{\"target_end\": \"${PERIOD_END}\"}" > /dev/null

          echo "ENGAGEMENT_STATUS=reused" >> $GITHUB_ENV

        else
          echo " CrÃ©ation d'un nouvel engagement : $ENGAGEMENT_NAME"

          # Payload JSON construit proprement via jq
          # jq --arg garantit l'Ã©chappement correct de toutes les valeurs
          PAYLOAD=$(jq -n \
            --arg name        "$ENGAGEMENT_NAME" \
            --arg desc        "Scans CI/CD automatises | Branche: ${BRANCH} | Periode: ${PERIOD_START} -> ${PERIOD_END}" \
            --argjson product "$PRODUCT_ID" \
            --arg start       "$PERIOD_START" \
            --arg end         "$PERIOD_END" \
            --arg branch      "$BRANCH" \
            --arg period_mode "$PERIOD_MODE" \
            --arg period      "$PERIOD" \
            '{
              name:                        $name,
              description:                 $desc,
              product:                     $product,
              engagement_type:             "CI/CD",
              status:                      "In Progress",
              target_start:                $start,
              target_end:                  $end,
              branch_tag:                  $branch,
              deduplication_on_engagement: false,
              tags: ["github-actions", $branch, $period_mode, $period, "automated"]
            }')

          CREATE=$(curl -s -X POST "${DD_URL}/api/v2/engagements/" \
            -H "Authorization: Token $DD_API_KEY" \
            -H "Content-Type: application/json" \
            -d "$PAYLOAD")

          # VÃ©rification via jq
          ENGAGEMENT_ID=$(echo "$CREATE" | jq -r '.id // empty')

          if [ -z "$ENGAGEMENT_ID" ] || [ "$ENGAGEMENT_ID" = "null" ]; then
            echo " Ã‰chec de crÃ©ation de l'engagement. RÃ©ponse API :"
            echo "$CREATE" | jq .
            exit 1
          fi

          echo " Engagement crÃ©Ã© â€” ID: $ENGAGEMENT_ID"
          echo "ENGAGEMENT_STATUS=created" >> $GITHUB_ENV
        fi

        # â”€â”€ Export complet pour les steps suivants â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        {
          echo "ENGAGEMENT_ID=$ENGAGEMENT_ID"
          echo "ENGAGEMENT_NAME=$ENGAGEMENT_NAME"
          echo "BRANCH=$BRANCH"
          echo "PERIOD=$PERIOD"
          echo "PERIOD_START=$PERIOD_START"
          echo "PERIOD_END=$PERIOD_END"
        } >> $GITHUB_ENV

        echo "engagement_id=$ENGAGEMENT_ID" >> $GITHUB_OUTPUT

        echo ""
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo "  âœ… Engagement rÃ©solu"
        echo "  ID   : $ENGAGEMENT_ID"
        echo "  Nom  : $ENGAGEMENT_NAME"
        echo "  Lien : ${DD_URL}/engagements/${ENGAGEMENT_ID}/finding/"
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

    
    - name:  DefectDojo â€” Snapshot avant import
      if: always()
      env:
        DD_API_KEY: ${{ secrets.DEFECTDOJO_API_KEY }}
      run: |
        echo " Capture des findings actifs AVANT rÃ©import..."

        TOTAL=$(curl -s \
          "${DD_URL}/api/v2/findings/?engagement=${ENGAGEMENT_ID}&active=true&limit=1" \
          -H "Authorization: Token $DD_API_KEY" | jq -r '.count // 0')

        echo "FINDINGS_BEFORE=$TOTAL" >> $GITHUB_ENV

        for SEV in Critical High Medium Low Info; do
          COUNT=$(curl -s \
            "${DD_URL}/api/v2/findings/?engagement=${ENGAGEMENT_ID}&active=true&severity=${SEV}&limit=1" \
            -H "Authorization: Token $DD_API_KEY" | jq -r '.count // 0')
          echo "BEFORE_${SEV}=$COUNT" >> $GITHUB_ENV
          echo "  â€¢ $SEV : $COUNT"
        done

        echo " Total avant : $TOTAL findings actifs"

   
    - name:  DefectDojo â€” RÃ©import des scans
      if: always()
      continue-on-error: true
      env:
        DD_API_KEY: ${{ secrets.DEFECTDOJO_API_KEY }}
      run: |

        reimport_scan() {
          local file="$1"
          local scan_type="$2"
          local test_title="$3"
          local category="$4"

          if [ ! -f "$file" ] || [ ! -s "$file" ]; then
            echo "    âš ï¸ $test_title â€” fichier absent ou vide, skip"
            return 0
          fi

          RESPONSE=$(curl -s -X POST "${DD_URL}/api/v2/reimport-scan/" \
            -H "Authorization: Token $DD_API_KEY" \
            -F "engagement=${ENGAGEMENT_ID}" \
            -F "scan_type=${scan_type}" \
            -F "test_title=${test_title}" \
            -F "file=@${file}" \
            -F "active=true" \
            -F "verified=false" \
            -F "close_old_findings=true" \
            -F "close_old_findings_product_scope=false" \
            -F "minimum_severity=Info" \
            -F "environment=Development" \
            -F "branch_tag=${{ github.ref_name }}" \
            -F "commit_hash=${{ github.sha }}" \
            -F "build_id=${{ github.run_id }}" \
            -F "tags=${category},github-actions,automated" \
            2>&1) || true

          # Parsing de la rÃ©ponse avec jq
          TEST_ID=$(echo "$RESPONSE" | jq -r '.test // .id // "?"' 2>/dev/null || echo "?")
          NEW_F=$(echo "$RESPONSE"   | jq -r '.finding_count // 0'   2>/dev/null || echo "0")
          CLOSED_F=$(echo "$RESPONSE"| jq -r '.closed_findings // 0'  2>/dev/null || echo "0")
          SKIP_F=$(echo "$RESPONSE"  | jq -r '.skipped_findings // 0' 2>/dev/null || echo "0")

          if [ "$TEST_ID" != "?" ] && [ "$TEST_ID" != "null" ]; then
            echo "   $test_title | Test ID: $TEST_ID | new=$NEW_F closed=$CLOSED_F skipped=$SKIP_F"
          else
            echo "   $test_title | Erreur API :"
            echo "$RESPONSE" | jq . 2>/dev/null || echo "$RESPONSE"
          fi

        }

        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo "   SAST â€” Static Application Security Testing"
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        reimport_scan \
          "juice-shop/semgrep-results.json" \
          "Semgrep JSON Report" \
          "SAST - Semgrep" \
          "SAST"

        echo ""
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo "   SCA â€” Software Composition Analysis"
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        reimport_scan \
          "juice-shop/snyk-results.json" \
          "Snyk Scan" \
          "SCA - Snyk" \
          "SCA"

        echo ""
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo "   DAST â€” Dynamic Application Security Testing"
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        reimport_scan \
          "juice-shop/zap-openapi.xml" \
          "ZAP Scan" \
          "DAST - ZAP OpenAPI" \
          "DAST"

        reimport_scan \
          "juice-shop/zap-spider.xml" \
          "ZAP Scan" \
          "DAST - ZAP Spider" \
          "DAST"

        reimport_scan \
          "juice-shop/zap-active.xml" \
          "ZAP Scan" \
          "DAST - ZAP Active Scan" \
          "DAST"

    
    - name:  DefectDojo â€” Rapport final & Security Gate
      if: always()
      env:
        DD_API_KEY: ${{ secrets.DEFECTDOJO_API_KEY }}
      run: |
        echo ""
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo "    DEFECTDOJO â€” RAPPORT DE SÃ‰CURITÃ‰ CI/CD"
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo "  Engagement  : $ENGAGEMENT_NAME"
        if [ "$ENGAGEMENT_STATUS" = "created" ]; then
          echo "  Statut      :  CrÃ©Ã© ce run"
        else
          echo "  Statut      :   RÃ©utilisÃ© (existant)"
        fi
        echo "  Lien        : ${DD_URL}/engagements/${ENGAGEMENT_ID}/finding/"
        echo ""

        # EntÃªte du tableau
        printf "  %-14s â”‚ %5s â”‚ %5s â”‚ %s\n" "SÃ©vÃ©ritÃ©" "Avant" "AprÃ¨s" "Delta"
        echo "  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"

        # Security Gate flags
        GATE_FAILED=0
        NEW_CRITICAL=0
        NEW_HIGH=0

        for SEV in Critical High Medium Low Info; do
          # RÃ©cupÃ©ration du count APRÃˆS import
          AFTER=$(curl -s \
            "${DD_URL}/api/v2/findings/?engagement=${ENGAGEMENT_ID}&active=true&severity=${SEV}&limit=1" \
            -H "Authorization: Token $DD_API_KEY" | jq -r '.count // 0')

          # RÃ©cupÃ©ration du count AVANT (sauvegardÃ© dans GITHUB_ENV)
          BEFORE_VAR="BEFORE_${SEV}"
          BEFORE="${!BEFORE_VAR}"
          BEFORE="${BEFORE:-0}"

          # Calcul du delta
          DELTA=$((AFTER - BEFORE))

          # IcÃ´ne selon sÃ©vÃ©ritÃ©
          case "$SEV" in
            Critical) ICON="ğŸ”´" ;;
            High)     ICON="ğŸŸ " ;;
            Medium)   ICON="ğŸŸ¡" ;;
            Low)      ICON="ğŸ”µ" ;;
            Info)     ICON="âšª" ;;
          esac

          # FlÃ¨che delta
          if [ "$DELTA" -gt 0 ]; then
            DELTA_STR="+${DELTA} ğŸ”º"
          elif [ "$DELTA" -lt 0 ]; then
            DELTA_STR="${DELTA} âœ…"
          else
            DELTA_STR="  â€”"
          fi

          printf "  %s %-12s â”‚ %5s â”‚ %5s â”‚ %s\n" "$ICON" "$SEV" "$BEFORE" "$AFTER" "$DELTA_STR"

          # Security Gate tracking
          if [ "$SEV" = "Critical" ] && [ "$DELTA" -gt 0 ]; then
            NEW_CRITICAL=$DELTA
          fi
          if [ "$SEV" = "High" ] && [ "$DELTA" -gt 0 ]; then
            NEW_HIGH=$DELTA
          fi
        done

        echo ""
        echo "  Total actifs avant ce run : $FINDINGS_BEFORE"

        # Total aprÃ¨s
        TOTAL_AFTER=$(curl -s \
          "${DD_URL}/api/v2/findings/?engagement=${ENGAGEMENT_ID}&active=true&limit=1" \
          -H "Authorization: Token $DD_API_KEY" | jq -r '.count // 0')
        echo "  Total actifs aprÃ¨s ce run : $TOTAL_AFTER"

        TOTAL_DIFF=$((TOTAL_AFTER - FINDINGS_BEFORE))

        if [ "$TOTAL_DIFF" -eq 0 ]; then
          echo ""
          echo "  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”"
          echo "  â”‚  â„¹ï¸  AUCUN CHANGEMENT dÃ©tectÃ© dans ce run     â”‚"
          echo "  â”‚  Les findings sont identiques au run         â”‚"
          echo "  â”‚  prÃ©cÃ©dent. Engagement mis Ã  jour.           â”‚"
          echo "  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜"
        elif [ "$TOTAL_DIFF" -gt 0 ]; then
          echo ""
          echo "  ğŸ”º $TOTAL_DIFF nouveau(x) finding(s) dÃ©tectÃ©(s) ce run !"
        else
          ABS_DIFF=$(( TOTAL_DIFF * -1 ))
          echo ""
          echo "  ğŸŸ¢ $ABS_DIFF finding(s) rÃ©solu(s) depuis le dernier run !"
        fi

        echo ""
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

        # â”€â”€ Security Gate â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        if [ "$FAIL_ON_NEW_CRITICAL" = "true" ] && [ "$NEW_CRITICAL" -gt 0 ]; then
          echo ""
          echo "ğŸš¨ SECURITY GATE FAILED !"
          echo "   $NEW_CRITICAL nouveau(x) finding(s) CRITICAL introduit(s)."
          echo "   âœ Corrige les vulnÃ©rabilitÃ©s critiques avant de merger."
          GATE_FAILED=1
        fi

        if [ "$FAIL_ON_NEW_HIGH" = "true" ] && [ "$NEW_HIGH" -gt 0 ]; then
          echo ""
          echo "â›” SECURITY GATE FAILED !"
          echo "   $NEW_HIGH nouveau(x) finding(s) HIGH introduit(s)."
          GATE_FAILED=1
        fi

        if [ "$GATE_FAILED" -eq 0 ]; then
          echo ""
          echo "âœ… Security Gate : PASSED"
        fi

        exit $GATE_FAILED

    
    - name:  Pipeline terminÃ©
      if: always()
      run: |
        echo " DevSecOps pipeline exÃ©cutÃ© avec succÃ¨s"
        echo "   Branche              : ${{ github.ref_name }}"
        echo "   Commit               : ${{ github.sha }}"
        echo "   Run ID               : ${{ github.run_id }}"
        echo "   DefectDojo Engagement: $ENGAGEMENT_NAME (ID: $ENGAGEMENT_ID)"
        echo "   ğŸ”— ${DD_URL}/engagements/${ENGAGEMENT_ID}/finding/"