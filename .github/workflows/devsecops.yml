name: ğŸ”’ DevSecOps Pipeline - InvisiThreat (SAST + SCA)

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]
  workflow_dispatch:  # Permet l'exÃ©cution manuelle

env:
  APP_NAME: InvisiThreat
  APP_DIR: ./juice-shop
  DD_URL: http://localhost:8080
  FAIL_ON_NEW_CRITICAL: "true"
  FAIL_ON_NEW_HIGH: "false"

jobs:
  security:
    name: ğŸ” SAST + SCA + DefectDojo
    runs-on: self-hosted
    timeout-minutes: 60

    steps:
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 1. CHECKOUT
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    - name: ğŸ“¥ RÃ©cupÃ©rer le code
      uses: actions/checkout@v4
      with:
        submodules: recursive
        fetch-depth: 0

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 2. OUTILLAGE
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    - name: ğŸ“¦ Installer jq
      run: |
        if command -v jq &>/dev/null; then
          echo "âœ… jq dÃ©jÃ  installÃ© : $(jq --version)"
          exit 0
        fi
        echo "ğŸ”§ Nettoyage des verrous apt..."
        sudo killall apt apt-get dpkg 2>/dev/null || true
        sudo rm -f /var/lib/dpkg/lock-frontend \
                   /var/lib/dpkg/lock \
                   /var/cache/apt/archives/lock \
                   /var/lib/apt/lists/lock
        sudo dpkg --configure -a
        if sudo apt-get update -qq && sudo apt-get install -y -qq jq; then
          echo "âœ… jq installÃ© via apt : $(jq --version)"
        else
          echo "âš ï¸ Ã‰chec apt â€“ installation du binaire statique..."
          wget -q -O jq \
            https://github.com/jqlang/jq/releases/download/jq-1.7.1/jq-linux64
          chmod +x jq && sudo mv jq /usr/local/bin/
          echo "âœ… jq installÃ© via binaire : $(jq --version)"
        fi

    - name: ğŸ“¦ Installer Python (pour urllib)
      run: |
        if ! command -v python3 &>/dev/null; then
          sudo apt-get update && sudo apt-get install -y python3
        fi
        echo "âœ… Python3 : $(python3 --version)"

    - name: Cache des dÃ©pendances Node
      uses: actions/cache@v3
      with:
        path: |
          ${{ env.APP_DIR }}/node_modules
          ${{ env.APP_DIR }}/frontend/node_modules
        key: ${{ runner.os }}-node-${{ hashFiles('${{ env.APP_DIR }}/package-lock.json', '${{ env.APP_DIR }}/frontend/package-lock.json') }}
        restore-keys: |
          ${{ runner.os }}-node-

    - name: Installer les dÃ©pendances Node
      working-directory: ${{ env.APP_DIR }}
      run: |
        if [ -f "package-lock.json" ]; then
          npm ci --no-audit --no-fund
        else
          npm install --no-audit --no-fund
        fi

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 3. DEFECTDOJO â€” PRODUCT
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    - name: ğŸ—ï¸ DefectDojo â€” CrÃ©er ou rÃ©cupÃ©rer le produit
      id: dd_product
      env:
        DD_API_KEY: ${{ secrets.DEFECTDOJO_API_KEY }}
      run: |
        set -e
        PRODUCT_NAME="${{ env.APP_NAME }}"
        DD_BASE="${{ env.DD_URL }}"

        echo "=== PRODUIT ==="
        echo "Recherche de : $PRODUCT_NAME"
        
        ENCODED=$(python3 -c "import urllib.parse; print(urllib.parse.quote('$PRODUCT_NAME'))")
        SEARCH=$(curl -sf "$DD_BASE/api/v2/products/?name=$ENCODED" \
          -H "Authorization: Token $DD_API_KEY" \
          -H "Accept: application/json" || echo '{"count":0,"results":[]}')

        COUNT=$(echo "$SEARCH" | jq -r '.count // 0')

        if [ "$COUNT" -gt 0 ]; then
          PRODUCT_ID=$(echo "$SEARCH" | jq -r '.results[0].id')
          echo "â™»ï¸ Produit existant â€” ID=$PRODUCT_ID"
        else
          echo "â• CrÃ©ation du produit..."
          CREATE=$(curl -sf -X POST "$DD_BASE/api/v2/products/" \
            -H "Authorization: Token $DD_API_KEY" \
            -H "Content-Type: application/json" \
            -d "{
              \"name\": \"$PRODUCT_NAME\",
              \"description\": \"Analyse de sÃ©curitÃ© automatisÃ©e â€” $PRODUCT_NAME\",
              \"prod_type\": 1
            }")
          PRODUCT_ID=$(echo "$CREATE" | jq -r '.id')
          echo "âœ… Produit crÃ©Ã© â€” ID=$PRODUCT_ID"
        fi

        if [ -z "$PRODUCT_ID" ] || [ "$PRODUCT_ID" = "null" ]; then
          echo "âŒ ERREUR : Impossible d'obtenir un PRODUCT_ID valide"
          exit 1
        fi

        echo "product_id=$PRODUCT_ID" >> "$GITHUB_OUTPUT"
        echo "âœ… Produit OK â€” ID=$PRODUCT_ID"

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 4. DEFECTDOJO â€” ENGAGEMENT (branche + trimestre)
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    - name: ğŸ—“ï¸ DefectDojo â€” CrÃ©er ou rÃ©cupÃ©rer l'engagement
      id: dd_engagement
      env:
        DD_API_KEY: ${{ secrets.DEFECTDOJO_API_KEY }}
      run: |
        set -e
        PRODUCT_ID="${{ steps.dd_product.outputs.product_id }}"
        BRANCH="${{ github.ref_name }}"
        DD_BASE="${{ env.DD_URL }}"

        # Calcul du trimestre
        YEAR=$(date +%Y)
        MONTH=$(date +%-m)
        
        if [ "$MONTH" -le 3 ]; then 
          PERIOD="Q1"
          START_DATE="${YEAR}-01-01"
          END_DATE="${YEAR}-03-31"
        elif [ "$MONTH" -le 6 ]; then 
          PERIOD="Q2"
          START_DATE="${YEAR}-04-01"
          END_DATE="${YEAR}-06-30"
        elif [ "$MONTH" -le 9 ]; then 
          PERIOD="Q3"
          START_DATE="${YEAR}-07-01"
          END_DATE="${YEAR}-09-30"
        else 
          PERIOD="Q4"
          START_DATE="${YEAR}-10-01"
          END_DATE="${YEAR}-12-31"
        fi

        ENGAGEMENT_NAME="${BRANCH} - ${YEAR}-${PERIOD}"
        
        echo "=== ENGAGEMENT ==="
        echo "Nom     : $ENGAGEMENT_NAME"
        echo "Produit : $PRODUCT_ID"
        echo "PÃ©riode : $START_DATE â†’ $END_DATE"

        ENCODED=$(python3 -c "import urllib.parse; print(urllib.parse.quote('$ENGAGEMENT_NAME'))")
        SEARCH=$(curl -sf \
          "$DD_BASE/api/v2/engagements/?product=$PRODUCT_ID&name=$ENCODED" \
          -H "Authorization: Token $DD_API_KEY" \
          -H "Accept: application/json" || echo '{"count":0,"results":[]}')

        COUNT=$(echo "$SEARCH" | jq -r '.count // 0')

        if [ "$COUNT" -gt 0 ]; then
          ENGAGEMENT_ID=$(echo "$SEARCH" | jq -r '.results[0].id')
          echo "â™»ï¸ Engagement existant â€” ID=$ENGAGEMENT_ID"
          
          # Mise Ã  jour des mÃ©tadonnÃ©es
          curl -sf -X PATCH "$DD_BASE/api/v2/engagements/$ENGAGEMENT_ID/" \
            -H "Authorization: Token $DD_API_KEY" \
            -H "Content-Type: application/json" \
            -d "{
              \"target_end\": \"$END_DATE\",
              \"branch_tag\": \"$BRANCH\",
              \"build_id\": \"${{ github.run_id }}\",
              \"commit_hash\": \"${{ github.sha }}\"
            }" > /dev/null && echo "ğŸ“… MÃ©tadonnÃ©es mises Ã  jour"
        else
          echo "â• CrÃ©ation de l'engagement..."
          CREATE=$(curl -sf -X POST "$DD_BASE/api/v2/engagements/" \
            -H "Authorization: Token $DD_API_KEY" \
            -H "Content-Type: application/json" \
            -d "{
              \"name\": \"$ENGAGEMENT_NAME\",
              \"product\": $PRODUCT_ID,
              \"engagement_type\": \"CI/CD\",
              \"status\": \"In Progress\",
              \"branch_tag\": \"$BRANCH\",
              \"build_id\": \"${{ github.run_id }}\",
              \"commit_hash\": \"${{ github.sha }}\",
              \"source_code_management_uri\": \"${{ github.server_url }}/${{ github.repository }}\",
              \"target_start\": \"$START_DATE\",
              \"target_end\": \"$END_DATE\",
              \"description\": \"Pipeline CI/CD â€” $BRANCH â€” $YEAR-$PERIOD\"
            }")
          ENGAGEMENT_ID=$(echo "$CREATE" | jq -r '.id')
          echo "âœ… Engagement crÃ©Ã© â€” ID=$ENGAGEMENT_ID"
        fi

        if [ -z "$ENGAGEMENT_ID" ] || [ "$ENGAGEMENT_ID" = "null" ]; then
          echo "âŒ ERREUR : Impossible d'obtenir un ENGAGEMENT_ID valide"
          exit 1
        fi

        echo "engagement_id=$ENGAGEMENT_ID" >> "$GITHUB_OUTPUT"
        echo "engagement_name=$ENGAGEMENT_NAME" >> "$GITHUB_OUTPUT"
        echo "start_date=$START_DATE" >> "$GITHUB_OUTPUT"
        echo "end_date=$END_DATE" >> "$GITHUB_OUTPUT"
        echo "period=$PERIOD" >> "$GITHUB_OUTPUT"
        echo "âœ… Engagement OK â€” $ENGAGEMENT_NAME (ID=$ENGAGEMENT_ID)"

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 5. SNAPSHOT AVANT IMPORT
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    - name: ğŸ“Š Snapshot des findings AVANT import
      id: dd_snapshot
      env:
        DD_API_KEY: ${{ secrets.DEFECTDOJO_API_KEY }}
      run: |
        ENGAGEMENT_ID="${{ steps.dd_engagement.outputs.engagement_id }}"
        DD_BASE="${{ env.DD_URL }}"

        echo "=== SNAPSHOT AVANT IMPORT ==="
        
        RESP=$(curl -sf \
          "$DD_BASE/api/v2/findings/?engagement=$ENGAGEMENT_ID&limit=500&active=true" \
          -H "Authorization: Token $DD_API_KEY" \
          -H "Accept: application/json" || echo '{"count":0,"results":[]}')

        BEFORE_TOTAL=$(echo "$RESP" | jq -r '.count // 0')
        BEFORE_CRITICAL=$(echo "$RESP" | jq '[.results[]? | select(.severity=="Critical")] | length' 2>/dev/null || echo 0)
        BEFORE_HIGH=$(echo "$RESP" | jq '[.results[]? | select(.severity=="High")] | length' 2>/dev/null || echo 0)

        echo "ğŸ“Š Findings actifs avant import :"
        echo "   Total    : $BEFORE_TOTAL"
        echo "   Critical : $BEFORE_CRITICAL"
        echo "   High     : $BEFORE_HIGH"
        
        echo "before_total=$BEFORE_TOTAL" >> "$GITHUB_OUTPUT"
        echo "before_critical=$BEFORE_CRITICAL" >> "$GITHUB_OUTPUT"
        echo "before_high=$BEFORE_HIGH" >> "$GITHUB_OUTPUT"

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 6. SAST â€” Semgrep
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    - name: ğŸ” SAST â€” Semgrep
      working-directory: ${{ env.APP_DIR }}
      continue-on-error: true
      run: |
        echo "=== SEMGREP SCAN ==="
        echo "ğŸ” Scan en cours..."
        
        docker run --rm -v "$(pwd)":/src returntocorp/semgrep semgrep \
          --config=p/security-audit \
          --config=p/owasp-top-ten \
          --json \
          --output=semgrep-results.json \
          /src || true

        if [ ! -f semgrep-results.json ]; then
          echo '{"results":[]}' > semgrep-results.json
          echo "âš ï¸ Rapport Semgrep vide crÃ©Ã©"
        else
          COUNT=$(jq '.results | length' semgrep-results.json 2>/dev/null || echo 0)
          echo "âœ… Semgrep terminÃ© : $COUNT rÃ©sultat(s)"
        fi

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 7. SCA â€” Snyk
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    - name: ğŸ“¦ SCA â€” Snyk test
      working-directory: ${{ env.APP_DIR }}
      continue-on-error: true
      env:
        SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
      run: |
        echo "=== SNYK SCAN ==="
        echo "ğŸ” Scan en cours..."
        
        npx snyk test --severity-threshold=low \
          --json-file-output=snyk-results.json || true

        if [ ! -s snyk-results.json ]; then
          echo '{"vulnerabilities":[]}' > snyk-results.json
          echo "âš ï¸ Rapport Snyk vide crÃ©Ã©"
        else
          COUNT=$(jq '.vulnerabilities | length' snyk-results.json 2>/dev/null || echo 0)
          echo "âœ… Snyk terminÃ© : $COUNT vulnÃ©rabilitÃ©(s)"
        fi

    - name: ğŸ“Š SCA â€” Snyk monitor
      working-directory: ${{ env.APP_DIR }}
      continue-on-error: true
      env:
        SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
      run: |
        echo "ğŸ“Š Snyk monitor..."
        npx snyk monitor || true

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 8. UPLOAD DES RAPPORTS
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    - name: ğŸ“¤ Upload des rapports de sÃ©curitÃ©
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: security-reports-${{ github.sha }}
        path: |
          ${{ env.APP_DIR }}/semgrep-results.json
          ${{ env.APP_DIR }}/snyk-results.json
        retention-days: 30
        if-no-files-found: warn

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # 9. IMPORT DANS DEFECTDOJO (VERSION CORRIGÃ‰E)
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    - name: ğŸ“¤ Importer les rÃ©sultats dans DefectDojo
      if: always()
      continue-on-error: true
      env:
        DD_API_KEY: ${{ secrets.DEFECTDOJO_API_KEY }}
      run: |
        ENGAGEMENT_ID="${{ steps.dd_engagement.outputs.engagement_id }}"
        BRANCH="${{ github.ref_name }}"
        SHA="${{ github.sha }}"
        RUN_ID="${{ github.run_id }}"
        DD_BASE="${{ env.DD_URL }}"

        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo "  IMPORT DES RAPPORTS DE SÃ‰CURITÃ‰"
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo "  Engagement ID : $ENGAGEMENT_ID"
        echo "  Branche       : $BRANCH"
        echo "  Commit        : $SHA"
        echo "  Build ID      : $RUN_ID"
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

        # Fonction d'import amÃ©liorÃ©e
        dd_import() {
          local LABEL="$1"
          local SCAN_TYPE="$2"
          local FILE="$3"

          echo ""
          echo "â–¶ï¸  Traitement : $LABEL"
          echo "   Scan Type : $SCAN_TYPE"
          echo "   Fichier   : $FILE"

          # VÃ©rification du fichier
          if [ ! -f "$FILE" ]; then
            echo "   âš ï¸ Fichier non trouvÃ© - ignorÃ©"
            return
          fi
          
          if [ ! -s "$FILE" ]; then
            echo "   âš ï¸ Fichier vide - ignorÃ©"
            return
          fi

          # Taille du fichier
          SIZE=$(du -h "$FILE" | cut -f1)
          echo "   Taille    : $SIZE"

          # VÃ©rification que le scan_type existe dans DefectDojo
          echo "   ğŸ” VÃ©rification du scan_type..."
          ENCODED_TYPE=$(python3 -c "import urllib.parse; print(urllib.parse.quote('$SCAN_TYPE'))")
          TYPE_CHECK=$(curl -sf "$DD_BASE/api/v2/scan_types/?name=$ENCODED_TYPE" \
            -H "Authorization: Token $DD_API_KEY" \
            -H "Accept: application/json" || echo '{"count":0}')

          TYPE_COUNT=$(echo "$TYPE_CHECK" | jq -r '.count // 0')
          
          if [ "$TYPE_COUNT" -eq 0 ]; then
            echo "   âš ï¸ Scan type '$SCAN_TYPE' non trouvÃ© dans DefectDojo"
            echo "   Liste des scan_types disponibles :"
            curl -sf "$DD_BASE/api/v2/scan_types/?limit=10" \
              -H "Authorization: Token $DD_API_KEY" | jq -r '.results[] | "     - " + .name'
            return
          fi

          # Import
          echo "   ğŸ“¤ Import en cours..."
          RESPONSE=$(curl -s -X POST "$DD_BASE/api/v2/import-scan/" \
            -H "Authorization: Token $DD_API_KEY" \
            -F "engagement=$ENGAGEMENT_ID" \
            -F "scan_type=$SCAN_TYPE" \
            -F "file=@$FILE" \
            -F "close_old_findings=true" \
            -F "minimum_severity=Info" \
            -F "environment=Development" \
            -F "branch_tag=$BRANCH" \
            -F "commit_hash=$SHA" \
            -F "build_id=$RUN_ID")

          # Analyse de la rÃ©ponse
          if echo "$RESPONSE" | jq -e '.id' >/dev/null 2>&1; then
            IMPORT_ID=$(echo "$RESPONSE" | jq -r '.id')
            FINDING_COUNT=$(echo "$RESPONSE" | jq -r '.finding_count // 0')
            TEST_ID=$(echo "$RESPONSE" | jq -r '.test_id // "?"')
            echo "   âœ… IMPORT RÃ‰USSI !"
            echo "     - Import ID : $IMPORT_ID"
            echo "     - Test ID   : $TEST_ID"
            echo "     - Findings  : $FINDING_COUNT"
          else
            echo "   âŒ Ã‰CHEC DE L'IMPORT"
            ERROR_MSG=$(echo "$RESPONSE" | jq -r '.message // . // "Erreur inconnue"' | head -c 200)
            echo "     - Erreur: $ERROR_MSG"
            
            # AperÃ§u du fichier pour debug
            echo "     - AperÃ§u du fichier (premiÃ¨res lignes):"
            head -5 "$FILE" | sed 's/^/       /'
          fi
        }

        # IMPORTS AVEC LES BONS SCAN_TYPES
        dd_import "Semgrep SAST" "Semgrep JSON Report" "${{ env.APP_DIR }}/semgrep-results.json"
        dd_import "Snyk SCA"     "Snyk Scan"           "${{ env.APP_DIR }}/snyk-results.json"

        echo ""
        echo "âœ… IMPORT TERMINÃ‰"

    
    - name: ğŸ“Š Rapport final et Security Gate
      if: always()
      env:
        DD_API_KEY: ${{ secrets.DEFECTDOJO_API_KEY }}
      run: |
        ENGAGEMENT_ID="${{ steps.dd_engagement.outputs.engagement_id }}"
        DD_BASE="${{ env.DD_URL }}"

        echo "=== RAPPORT FINAL ==="
        
        # RÃ©cupÃ©ration des findings aprÃ¨s import
        RESP=$(curl -sf \
          "$DD_BASE/api/v2/findings/?engagement=$ENGAGEMENT_ID&limit=500&active=true" \
          -H "Authorization: Token $DD_API_KEY" \
          -H "Accept: application/json" || echo '{"count":0,"results":[]}')

        AFTER_TOTAL=$(echo "$RESP" | jq -r '.count // 0')
        AFTER_CRITICAL=$(echo "$RESP" | jq '[.results[]? | select(.severity=="Critical")] | length' 2>/dev/null || echo 0)
        AFTER_HIGH=$(echo "$RESP" | jq '[.results[]? | select(.severity=="High")] | length' 2>/dev/null || echo 0)
        AFTER_MEDIUM=$(echo "$RESP" | jq '[.results[]? | select(.severity=="Medium")] | length' 2>/dev/null || echo 0)
        AFTER_LOW=$(echo "$RESP" | jq '[.results[]? | select(.severity=="Low")] | length' 2>/dev/null || echo 0)

        # Calcul des nouveaux findings
        BEFORE_TOTAL="${{ steps.dd_snapshot.outputs.before_total }}"
        BEFORE_CRITICAL="${{ steps.dd_snapshot.outputs.before_critical }}"
        BEFORE_HIGH="${{ steps.dd_snapshot.outputs.before_high }}"

        NEW_TOTAL=$((AFTER_TOTAL - BEFORE_TOTAL))
        NEW_CRITICAL=$((AFTER_CRITICAL - BEFORE_CRITICAL))
        NEW_HIGH=$((AFTER_HIGH - BEFORE_HIGH))

        [ "$NEW_CRITICAL" -lt 0 ] && NEW_CRITICAL=0
        [ "$NEW_HIGH" -lt 0 ] && NEW_HIGH=0

        # Affichage du rapport
        echo ""
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo "  RAPPORT FINAL DE SÃ‰CURITÃ‰"
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo "  Produit    : ${{ env.APP_NAME }} (ID=${{ steps.dd_product.outputs.product_id }})"
        echo "  Engagement : ${{ steps.dd_engagement.outputs.engagement_name }} (ID=$ENGAGEMENT_ID)"
        echo "  Branche    : ${{ github.ref_name }}"
        echo "  Commit     : ${{ github.sha }}"
        echo ""
        echo "  Ã‰VOLUTION DES FINDINGS :"
        echo "    Avant â†’ AprÃ¨s : $BEFORE_TOTAL â†’ $AFTER_TOTAL ($NEW_TOTAL nouveau(x))"
        echo ""
        echo "  FINDINGS ACTIFS :"
        echo "    ğŸ”´ Critical : $AFTER_CRITICAL (nouveaux: $NEW_CRITICAL)"
        echo "    ğŸŸ  High     : $AFTER_HIGH (nouveaux: $NEW_HIGH)"
        echo "    ğŸŸ¡ Medium   : $AFTER_MEDIUM"
        echo "    ğŸŸ¢ Low      : $AFTER_LOW"
        echo ""
        echo "  LIEN : $DD_BASE/engagements/$ENGAGEMENT_ID"
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

        # Security Gate
        FAILED=false
        
        if [ "${{ env.FAIL_ON_NEW_CRITICAL }}" = "true" ] && [ "$NEW_CRITICAL" -gt 0 ]; then
          echo "âŒ SECURITY GATE FAILED : $NEW_CRITICAL nouveau(x) Critical dÃ©tectÃ©(s) !"
          FAILED=true
        fi
        
        if [ "${{ env.FAIL_ON_NEW_HIGH }}" = "true" ] && [ "$NEW_HIGH" -gt 0 ]; then
          echo "âŒ SECURITY GATE FAILED : $NEW_HIGH nouveau(x) High dÃ©tectÃ©(s) !"
          FAILED=true
        fi

        if [ "$FAILED" = "true" ]; then
          exit 1
        else
          echo "âœ… SECURITY GATE PASSED"
        fi

   
    - name:  Pipeline terminÃ©
      if: always()
      run: |
        echo ""
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo "  âœ… DEVSECOPS PIPELINE â€” InvisiThreat"
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo "  Statut : TerminÃ©"
        echo "  Produit: ${{ env.APP_NAME }} (ID ${{ steps.dd_product.outputs.product_id }})"
        echo "  Commit : ${{ github.sha }}"
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"